//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.5
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


public class NeoNativeEngine {
  public static uint getNextPowerOfTwo(uint x) {
    uint ret = NeoNativeEnginePINVOKE.getNextPowerOfTwo(x);
    return ret;
  }

  public static float loopFloat(float val, float min, float max) {
    float ret = NeoNativeEnginePINVOKE.loopFloat(val, min, max);
    return ret;
  }

  public static void sortFloatList(SWIGTYPE_p_int indexList, SWIGTYPE_p_float floatList, int start, int end) {
    NeoNativeEnginePINVOKE.sortFloatList__SWIG_0(SWIGTYPE_p_int.getCPtr(indexList), SWIGTYPE_p_float.getCPtr(floatList), start, end);
  }

  public static void sortFloatList(SWIGTYPE_p_float floatList, int start, int end) {
    NeoNativeEnginePINVOKE.sortFloatList__SWIG_1(SWIGTYPE_p_float.getCPtr(floatList), start, end);
  }

  public static bool isBoxToBoxCollision(Vector3 minA, Vector3 maxA, Vector3 minB, Vector3 maxB) {
    bool ret = NeoNativeEnginePINVOKE.isBoxToBoxCollision(Vector3.getCPtr(minA), Vector3.getCPtr(maxA), Vector3.getCPtr(minB), Vector3.getCPtr(maxB));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isBoxToBox2dCollision(Vector2 minA, Vector2 maxA, Vector2 minB, Vector2 maxB) {
    bool ret = NeoNativeEnginePINVOKE.isBoxToBox2dCollision(Vector2.getCPtr(minA), Vector2.getCPtr(maxA), Vector2.getCPtr(minB), Vector2.getCPtr(maxB));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isPointInBox(Vector3 point, Vector3 min, Vector3 max) {
    bool ret = NeoNativeEnginePINVOKE.isPointInBox(Vector3.getCPtr(point), Vector3.getCPtr(min), Vector3.getCPtr(max));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isPointInBox2d(Vector2 point, Vector2 min, Vector2 max) {
    bool ret = NeoNativeEnginePINVOKE.isPointInBox2d(Vector2.getCPtr(point), Vector2.getCPtr(min), Vector2.getCPtr(max));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgeToBoxCollision(Vector3 origin, Vector3 dest, Vector3 min, Vector3 max) {
    bool ret = NeoNativeEnginePINVOKE.isEdgeToBoxCollision(Vector3.getCPtr(origin), Vector3.getCPtr(dest), Vector3.getCPtr(min), Vector3.getCPtr(max));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgeToEdge2dIntersection(Vector2 A, Vector2 B, Vector2 C, Vector2 D, Vector2 I) {
    bool ret = NeoNativeEnginePINVOKE.isEdgeToEdge2dIntersection(Vector2.getCPtr(A), Vector2.getCPtr(B), Vector2.getCPtr(C), Vector2.getCPtr(D), Vector2.getCPtr(I));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isPointInTriangle(Vector3 point, Vector3 a, Vector3 b, Vector3 c, Vector3 normal) {
    bool ret = NeoNativeEnginePINVOKE.isPointInTriangle(Vector3.getCPtr(point), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), Vector3.getCPtr(normal));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isLineCircleIntersection(Vector2 origin, Vector2 dest, Vector2 circleCenter, float circleRadius) {
    bool ret = NeoNativeEnginePINVOKE.isLineCircleIntersection(Vector2.getCPtr(origin), Vector2.getCPtr(dest), Vector2.getCPtr(circleCenter), circleRadius);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isRaySphereIntersection(Vector3 origin, Vector3 direction, Vector3 sphereCenter, float sphereRadius, Vector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isRaySphereIntersection(Vector3.getCPtr(origin), Vector3.getCPtr(direction), Vector3.getCPtr(sphereCenter), sphereRadius, Vector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isRayPlaneIntersection(Vector3 origin, Vector3 direction, Vector3 planePoint, Vector3 planeNormal, Vector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isRayPlaneIntersection(Vector3.getCPtr(origin), Vector3.getCPtr(direction), Vector3.getCPtr(planePoint), Vector3.getCPtr(planeNormal), Vector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgePlaneIntersection(Vector3 origin, Vector3 dest, Vector3 planePoint, Vector3 normal, Vector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isEdgePlaneIntersection(Vector3.getCPtr(origin), Vector3.getCPtr(dest), Vector3.getCPtr(planePoint), Vector3.getCPtr(normal), Vector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgeTriangleIntersection(Vector3 origin, Vector3 dest, Vector3 a, Vector3 b, Vector3 c, Vector3 normal, Vector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isEdgeTriangleIntersection(Vector3.getCPtr(origin), Vector3.getCPtr(dest), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), Vector3.getCPtr(normal), Vector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector3 getTriangleNormal(Vector3 a, Vector3 b, Vector3 c) {
    Vector3 ret = new Vector3(NeoNativeEnginePINVOKE.getTriangleNormal(Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static void simplifyDP(float tol, Vector3 v, int j, int k, SWIGTYPE_p_int mk) {
    NeoNativeEnginePINVOKE.simplifyDP(tol, Vector3.getCPtr(v), j, k, SWIGTYPE_p_int.getCPtr(mk));
  }

  public static float linearInterpolation(float y1, float y2, float mu) {
    float ret = NeoNativeEnginePINVOKE.linearInterpolation(y1, y2, mu);
    return ret;
  }

  public static float cubicInterpolation(float y0, float y1, float y2, float y3, float mu) {
    float ret = NeoNativeEnginePINVOKE.cubicInterpolation(y0, y1, y2, y3, mu);
    return ret;
  }

  public static float CatmullRomInterpolation(float y0, float y1, float y2, float y3, float mu) {
    float ret = NeoNativeEnginePINVOKE.CatmullRomInterpolation(y0, y1, y2, y3, mu);
    return ret;
  }

  public static float HermiteInterpolation(float y0, float y1, float y2, float y3, float mu, float tension, float bias, bool begin, bool end) {
    float ret = NeoNativeEnginePINVOKE.HermiteInterpolation__SWIG_0(y0, y1, y2, y3, mu, tension, bias, begin, end);
    return ret;
  }

  public static float HermiteInterpolation(float y0, float y1, float y2, float y3, float mu, float tension, float bias, bool begin) {
    float ret = NeoNativeEnginePINVOKE.HermiteInterpolation__SWIG_1(y0, y1, y2, y3, mu, tension, bias, begin);
    return ret;
  }

  public static float HermiteInterpolation(float y0, float y1, float y2, float y3, float mu, float tension, float bias) {
    float ret = NeoNativeEnginePINVOKE.HermiteInterpolation__SWIG_2(y0, y1, y2, y3, mu, tension, bias);
    return ret;
  }

  public static float HueToRGB(float v1, float v2, float vH) {
    float ret = NeoNativeEnginePINVOKE.HueToRGB(v1, v2, vH);
    return ret;
  }

  public static Vector3 RGBToHSV(Vector3 rgbColor) {
    Vector3 ret = new Vector3(NeoNativeEnginePINVOKE.RGBToHSV(Vector3.getCPtr(rgbColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector3 HSVToRGB(Vector3 HSVColor) {
    Vector3 ret = new Vector3(NeoNativeEnginePINVOKE.HSVToRGB(Vector3.getCPtr(HSVColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector3 RGBToHSL(Vector3 rgbColor) {
    Vector3 ret = new Vector3(NeoNativeEnginePINVOKE.RGBToHSL(Vector3.getCPtr(rgbColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector3 HSLToRGB(Vector3 hslColor) {
    Vector3 ret = new Vector3(NeoNativeEnginePINVOKE.HSLToRGB(Vector3.getCPtr(hslColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static void getLocalFilename(string arg0, string workingDirectory, string filename) {
    NeoNativeEnginePINVOKE.getLocalFilename(arg0, workingDirectory, filename);
  }

  public static void getGlobalFilename(string arg0, string workingDirectory, string filename) {
    NeoNativeEnginePINVOKE.getGlobalFilename(arg0, workingDirectory, filename);
  }

  public static void getRepertory(string arg0, string filename) {
    NeoNativeEnginePINVOKE.getRepertory(arg0, filename);
  }

  public static string readTextFile(string filename) {
    string ret = NeoNativeEnginePINVOKE.readTextFile(filename);
    return ret;
  }

  public static readonly double M_PI = NeoNativeEnginePINVOKE.M_PI_get();
  public static readonly double DEG_TO_RAD = NeoNativeEnginePINVOKE.DEG_TO_RAD_get();
  public static readonly double RAD_TO_DEG = NeoNativeEnginePINVOKE.RAD_TO_DEG_get();
  public static readonly int M_OBJECT3D = NeoNativeEnginePINVOKE.M_OBJECT3D_get();
  public static readonly int M_OBJECT3D_BONE = NeoNativeEnginePINVOKE.M_OBJECT3D_BONE_get();
  public static readonly int M_OBJECT3D_CAMERA = NeoNativeEnginePINVOKE.M_OBJECT3D_CAMERA_get();
  public static readonly int M_OBJECT3D_LIGHT = NeoNativeEnginePINVOKE.M_OBJECT3D_LIGHT_get();
  public static readonly int M_OBJECT3D_ENTITY = NeoNativeEnginePINVOKE.M_OBJECT3D_ENTITY_get();
  public static readonly int M_OBJECT3D_SOUND = NeoNativeEnginePINVOKE.M_OBJECT3D_SOUND_get();
  public static readonly int M_OBJECT3D_TEXT = NeoNativeEnginePINVOKE.M_OBJECT3D_TEXT_get();
  public static readonly int M_REF_MESH = NeoNativeEnginePINVOKE.M_REF_MESH_get();
  public static readonly int M_REF_TEXTURE = NeoNativeEnginePINVOKE.M_REF_TEXTURE_get();
  public static readonly int M_REF_SOUND = NeoNativeEnginePINVOKE.M_REF_SOUND_get();
  public static readonly int M_REF_ARMATURE_ANIM = NeoNativeEnginePINVOKE.M_REF_ARMATURE_ANIM_get();
  public static readonly int M_REF_MATERIALS_ANIM = NeoNativeEnginePINVOKE.M_REF_MATERIALS_ANIM_get();
  public static readonly int M_REF_TEXTURES_ANIM = NeoNativeEnginePINVOKE.M_REF_TEXTURES_ANIM_get();
  public static readonly int M_REF_SHADER = NeoNativeEnginePINVOKE.M_REF_SHADER_get();
  public static readonly int M_REF_FONT = NeoNativeEnginePINVOKE.M_REF_FONT_get();
}
