/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */


public class NeoNativeEngine {
  public static uint getNextPowerOfTwo(uint x) {
    uint ret = NeoNativeEnginePINVOKE.getNextPowerOfTwo(x);
    return ret;
  }

  public static float loopFloat(float val, float min, float max) {
    float ret = NeoNativeEnginePINVOKE.loopFloat(val, min, max);
    return ret;
  }

  public static void sortFloatList(SWIGTYPE_p_int indexList, SWIGTYPE_p_float floatList, int start, int end) {
    NeoNativeEnginePINVOKE.sortFloatList__SWIG_0(SWIGTYPE_p_int.getCPtr(indexList), SWIGTYPE_p_float.getCPtr(floatList), start, end);
  }

  public static void sortFloatList(SWIGTYPE_p_float floatList, int start, int end) {
    NeoNativeEnginePINVOKE.sortFloatList__SWIG_1(SWIGTYPE_p_float.getCPtr(floatList), start, end);
  }

  public static bool isBoxToBoxCollision(MVector3 minA, MVector3 maxA, MVector3 minB, MVector3 maxB) {
    bool ret = NeoNativeEnginePINVOKE.isBoxToBoxCollision(MVector3.getCPtr(minA), MVector3.getCPtr(maxA), MVector3.getCPtr(minB), MVector3.getCPtr(maxB));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isBoxToBox2dCollision(MVector2 minA, MVector2 maxA, MVector2 minB, MVector2 maxB) {
    bool ret = NeoNativeEnginePINVOKE.isBoxToBox2dCollision(MVector2.getCPtr(minA), MVector2.getCPtr(maxA), MVector2.getCPtr(minB), MVector2.getCPtr(maxB));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isPointInBox(MVector3 point, MVector3 min, MVector3 max) {
    bool ret = NeoNativeEnginePINVOKE.isPointInBox(MVector3.getCPtr(point), MVector3.getCPtr(min), MVector3.getCPtr(max));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isPointInBox2d(MVector2 point, MVector2 min, MVector2 max) {
    bool ret = NeoNativeEnginePINVOKE.isPointInBox2d(MVector2.getCPtr(point), MVector2.getCPtr(min), MVector2.getCPtr(max));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgeToBoxCollision(MVector3 origin, MVector3 dest, MVector3 min, MVector3 max) {
    bool ret = NeoNativeEnginePINVOKE.isEdgeToBoxCollision(MVector3.getCPtr(origin), MVector3.getCPtr(dest), MVector3.getCPtr(min), MVector3.getCPtr(max));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgeToEdge2dIntersection(MVector2 A, MVector2 B, MVector2 C, MVector2 D, MVector2 I) {
    bool ret = NeoNativeEnginePINVOKE.isEdgeToEdge2dIntersection(MVector2.getCPtr(A), MVector2.getCPtr(B), MVector2.getCPtr(C), MVector2.getCPtr(D), MVector2.getCPtr(I));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isPointInTriangle(MVector3 point, MVector3 a, MVector3 b, MVector3 c, MVector3 normal) {
    bool ret = NeoNativeEnginePINVOKE.isPointInTriangle(MVector3.getCPtr(point), MVector3.getCPtr(a), MVector3.getCPtr(b), MVector3.getCPtr(c), MVector3.getCPtr(normal));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isLineCircleIntersection(MVector2 origin, MVector2 dest, MVector2 circleCenter, float circleRadius) {
    bool ret = NeoNativeEnginePINVOKE.isLineCircleIntersection(MVector2.getCPtr(origin), MVector2.getCPtr(dest), MVector2.getCPtr(circleCenter), circleRadius);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isRaySphereIntersection(MVector3 origin, MVector3 direction, MVector3 sphereCenter, float sphereRadius, MVector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isRaySphereIntersection(MVector3.getCPtr(origin), MVector3.getCPtr(direction), MVector3.getCPtr(sphereCenter), sphereRadius, MVector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isRayPlaneIntersection(MVector3 origin, MVector3 direction, MVector3 planePoint, MVector3 planeNormal, MVector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isRayPlaneIntersection(MVector3.getCPtr(origin), MVector3.getCPtr(direction), MVector3.getCPtr(planePoint), MVector3.getCPtr(planeNormal), MVector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgePlaneIntersection(MVector3 origin, MVector3 dest, MVector3 planePoint, MVector3 normal, MVector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isEdgePlaneIntersection(MVector3.getCPtr(origin), MVector3.getCPtr(dest), MVector3.getCPtr(planePoint), MVector3.getCPtr(normal), MVector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isEdgeTriangleIntersection(MVector3 origin, MVector3 dest, MVector3 a, MVector3 b, MVector3 c, MVector3 normal, MVector3 point) {
    bool ret = NeoNativeEnginePINVOKE.isEdgeTriangleIntersection(MVector3.getCPtr(origin), MVector3.getCPtr(dest), MVector3.getCPtr(a), MVector3.getCPtr(b), MVector3.getCPtr(c), MVector3.getCPtr(normal), MVector3.getCPtr(point));
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MVector3 getTriangleNormal(MVector3 a, MVector3 b, MVector3 c) {
    MVector3 ret = new MVector3(NeoNativeEnginePINVOKE.getTriangleNormal(MVector3.getCPtr(a), MVector3.getCPtr(b), MVector3.getCPtr(c)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static void simplifyDP(float tol, MVector3 v, int j, int k, SWIGTYPE_p_int mk) {
    NeoNativeEnginePINVOKE.simplifyDP(tol, MVector3.getCPtr(v), j, k, SWIGTYPE_p_int.getCPtr(mk));
  }

  public static float linearInterpolation(float y1, float y2, float mu) {
    float ret = NeoNativeEnginePINVOKE.linearInterpolation(y1, y2, mu);
    return ret;
  }

  public static float cubicInterpolation(float y0, float y1, float y2, float y3, float mu) {
    float ret = NeoNativeEnginePINVOKE.cubicInterpolation(y0, y1, y2, y3, mu);
    return ret;
  }

  public static float CatmullRomInterpolation(float y0, float y1, float y2, float y3, float mu) {
    float ret = NeoNativeEnginePINVOKE.CatmullRomInterpolation(y0, y1, y2, y3, mu);
    return ret;
  }

  public static float HermiteInterpolation(float y0, float y1, float y2, float y3, float mu, float tension, float bias, bool begin, bool end) {
    float ret = NeoNativeEnginePINVOKE.HermiteInterpolation__SWIG_0(y0, y1, y2, y3, mu, tension, bias, begin, end);
    return ret;
  }

  public static float HermiteInterpolation(float y0, float y1, float y2, float y3, float mu, float tension, float bias, bool begin) {
    float ret = NeoNativeEnginePINVOKE.HermiteInterpolation__SWIG_1(y0, y1, y2, y3, mu, tension, bias, begin);
    return ret;
  }

  public static float HermiteInterpolation(float y0, float y1, float y2, float y3, float mu, float tension, float bias) {
    float ret = NeoNativeEnginePINVOKE.HermiteInterpolation__SWIG_2(y0, y1, y2, y3, mu, tension, bias);
    return ret;
  }

  public static float HueToRGB(float v1, float v2, float vH) {
    float ret = NeoNativeEnginePINVOKE.HueToRGB(v1, v2, vH);
    return ret;
  }

  public static MVector3 RGBToHSV(MVector3 rgbColor) {
    MVector3 ret = new MVector3(NeoNativeEnginePINVOKE.RGBToHSV(MVector3.getCPtr(rgbColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MVector3 HSVToRGB(MVector3 HSVColor) {
    MVector3 ret = new MVector3(NeoNativeEnginePINVOKE.HSVToRGB(MVector3.getCPtr(HSVColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MVector3 RGBToHSL(MVector3 rgbColor) {
    MVector3 ret = new MVector3(NeoNativeEnginePINVOKE.RGBToHSL(MVector3.getCPtr(rgbColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static MVector3 HSLToRGB(MVector3 hslColor) {
    MVector3 ret = new MVector3(NeoNativeEnginePINVOKE.HSLToRGB(MVector3.getCPtr(hslColor)), true);
    if (NeoNativeEnginePINVOKE.SWIGPendingException.Pending) throw NeoNativeEnginePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static void getLocalFilename(string arg0, string workingDirectory, string filename) {
    NeoNativeEnginePINVOKE.getLocalFilename(arg0, workingDirectory, filename);
  }

  public static void getGlobalFilename(string arg0, string workingDirectory, string filename) {
    NeoNativeEnginePINVOKE.getGlobalFilename(arg0, workingDirectory, filename);
  }

  public static void getRepertory(string arg0, string filename) {
    NeoNativeEnginePINVOKE.getRepertory(arg0, filename);
  }

  public static string readTextFile(string filename) {
    string ret = NeoNativeEnginePINVOKE.readTextFile(filename);
    return ret;
  }

  public static readonly double M_PI = NeoNativeEnginePINVOKE.M_PI_get();
  public static readonly double DEG_TO_RAD = NeoNativeEnginePINVOKE.DEG_TO_RAD_get();
  public static readonly double RAD_TO_DEG = NeoNativeEnginePINVOKE.RAD_TO_DEG_get();
  public static readonly int M_OBJECT3D = NeoNativeEnginePINVOKE.M_OBJECT3D_get();
  public static readonly int M_OBJECT3D_BONE = NeoNativeEnginePINVOKE.M_OBJECT3D_BONE_get();
  public static readonly int M_OBJECT3D_CAMERA = NeoNativeEnginePINVOKE.M_OBJECT3D_CAMERA_get();
  public static readonly int M_OBJECT3D_LIGHT = NeoNativeEnginePINVOKE.M_OBJECT3D_LIGHT_get();
  public static readonly int M_OBJECT3D_ENTITY = NeoNativeEnginePINVOKE.M_OBJECT3D_ENTITY_get();
  public static readonly int M_OBJECT3D_SOUND = NeoNativeEnginePINVOKE.M_OBJECT3D_SOUND_get();
  public static readonly int M_OBJECT3D_TEXT = NeoNativeEnginePINVOKE.M_OBJECT3D_TEXT_get();
  public static readonly int M_REF_MESH = NeoNativeEnginePINVOKE.M_REF_MESH_get();
  public static readonly int M_REF_TEXTURE = NeoNativeEnginePINVOKE.M_REF_TEXTURE_get();
  public static readonly int M_REF_SOUND = NeoNativeEnginePINVOKE.M_REF_SOUND_get();
  public static readonly int M_REF_ARMATURE_ANIM = NeoNativeEnginePINVOKE.M_REF_ARMATURE_ANIM_get();
  public static readonly int M_REF_MATERIALS_ANIM = NeoNativeEnginePINVOKE.M_REF_MATERIALS_ANIM_get();
  public static readonly int M_REF_TEXTURES_ANIM = NeoNativeEnginePINVOKE.M_REF_TEXTURES_ANIM_get();
  public static readonly int M_REF_SHADER = NeoNativeEnginePINVOKE.M_REF_SHADER_get();
  public static readonly int M_REF_FONT = NeoNativeEnginePINVOKE.M_REF_FONT_get();
}
